#' Helper Function to load different forms of data
#'
#' @param file_path The path to a file, either a .csv, .ods, excel file or SQLite database.
#' @param sheet If a .ods or excel file is loaded, this variable is required and specifies the sheet to be loaded.
#' @param na_strings A vector of strings that are to be interpreted as NA values. Default is "NA", "-99", "0", and "000".
#'
#' @return A table with all columns of the file or database
#' @importFrom utils read.table
#' @export
#'
#' @examples
#' \dontrun{
#' raw_data <- load_raw_data(file_path = "./data/bear_data_all.csv")
#' }
load_raw_data <- function(file_path, sheet = 1, na_strings = c("NA", "-99", "0", "000")) {
    if (endsWith(file_path, ".xls") | endsWith(file_path, ".xlsx")) {
        raw_data <- readxl::read_excel(path = file_path, col_names = TRUE, na = na_strings, sheet = sheet)
    } else if (endsWith(file_path, ".ods")) {
        raw_data <- readODS::read_ods(path = file_path, col_names = TRUE, na = na_strings, sheet = sheet)
    } else if (endsWith(file_path, ".db")) {
        raw_data <- GenotypeCheck::load_data_sqlite(file_path)
    } else {
        raw_data <- read.table(file = file_path, header = TRUE, na.strings = na_strings, sep = ",", stringsAsFactors = FALSE)
    }

    raw_data
}

#' Load Original Dataset
#'
#' @param raw_data A table/data.frame with all columns that are to be extracted. Generated by the "load_raw_data" function.
#' @param index_column The name of the column that contains indexes, a unique identifier for each row of data. In the example data
#' this column is called "index"
#' @param locus_columns A vector with the columns that contain the locus data. In the example data these are: c("G10L_1", "G10L_2",
#' "MU05_1", "MU05_2", ..., "MU59_2").
#' @param individ_column The name of the column that contains the id of the individual the sample belongs to. When loading new data to
#' be compared this is set to NA as the new data don't have any individual-classification
#' @param meta_columns A vector with the columns that contain the meta-data for each row. In the example data these are: c(date = "date",
#' north = "north", east = "east", gender = "gender"). The vector's names are required to be date, north, east, and gender.
#'
#' @return A list containing two object. 1. Data object that is used in the rest of this package. 2. A success message which contains usefull information.
#' @export
#'
#' @examples
#' \dontrun{
#' locus_columns <- c("MU09_1", "MU09_2", "MU10_1", "MU10_2", "MU05_1", "MU05_2",
#'     "MU23_1", "MU23_2", "MU51_1", "MU51_2", "MU59_1", "MU59_2", "G10L_1",
#'     "G10L_2", "MU50_1", "MU50_2")
#
#' names(locus_columns) <- c("MU09 - 1", "MU09 - 2", "MU10 - 1", "MU10 - 2", "MU05 - 1", "MU05 - 2",
#'     "MU23 - 1", "MU23 - 2", "MU51 - 1", "MU51 - 2", "MU59 - 1", "MU59 - 2", "G10L - 1",
#'     "G10L - 2", "MU50 - 1", "MU50 - 2")
#
#' c(data, success_message) %<-% load_data(load_raw_data(file_path = "./data/bear_data_all.csv"), index_column = "index",
#'     locus_columns = locus_columns, individ_column = "individ", meta_columns = c(gender = "gender",
#      date = "date", north = "north", east = "east", date_changed = "date_changed"))
#' }
load_data <- function(raw_data, index_column, locus_columns, individ_column = NA, meta_columns) {

    success_message <- ""

    if (raw_data %>% dplyr::select(dplyr::all_of(index_column)) %>% duplicated() %>% sum() >= 1) {
        warning("The indexes are not a unique identifier.")
        success_message <- success_message %>% paste0("The indexes are not a unique identifier.<br />")
    }

    if (is.na(individ_column)) {
        meta_data <- data.frame(raw_data %>% dplyr::select(dplyr::all_of(index_column), dplyr::all_of(meta_columns)), NA, NA)
        colnames(meta_data) <- c("index", names(meta_columns), "date_changed", "individ")
    } else {
        meta_data <- data.frame(raw_data %>% dplyr::select(dplyr::all_of(index_column), dplyr::all_of(meta_columns), dplyr::all_of(individ_column)))
        colnames(meta_data) <- c("index", names(meta_columns), "individ")
    }

    if (is.na(meta_columns["confirmed_dead"])) {
        meta_data <- cbind(meta_data, confirmed_dead = "No")
    }

    meta_data$confirmed_dead[is.na(meta_data$confirmed_dead)] <- "No"

    meta_NAs_before <- meta_data %>% apply(2, is.na)

    meta_data_save <- data.frame(meta_data)

    meta_data$north <- as.numeric(meta_data$north)
    meta_data$east <- as.numeric(meta_data$east)

    meta_NAs_after <- meta_data %>% apply(2, is.na)

    if (any(meta_NAs_before != meta_NAs_after)) {
        success_message <- success_message %>% paste0("The following meta data could not be converted into numbers: ",
                                                      paste0(meta_data_save[meta_NAs_before != meta_NAs_after], collapse = ", "), ".<br />")
    }

    rownames(meta_data) <- meta_data$index

    locus_data <- data.frame(raw_data %>% dplyr::select(dplyr::all_of(locus_columns)))
    locus_data_save <- data.frame(locus_data)

    locus_NAs_before <- locus_data %>% apply(2, is.na)

    locus_data <- locus_data %>%
        apply(1:2, as.numeric)

    locus_NAs_after <- locus_data %>% apply(2, is.na)

    if (any(locus_NAs_before != locus_NAs_after)) {
        success_message <- success_message %>% paste0("The following locus data could not be converted into numbers: ",
                                                      paste0(locus_data_save[locus_NAs_before != locus_NAs_after], collapse = ", "), ".<br />")
    }

    colnames(locus_data) <- c(names(locus_columns))
    rownames(locus_data) <- meta_data$index
    locus_data <- locus_data[,sort(colnames(locus_data))]

    combined_locus_data <- apply(locus_data, 1, combine_multilocus)

    data <- list(multilocus = locus_data, meta = meta_data, combined_locus_data = combined_locus_data, locus_column_names = names(locus_columns),
        meta_column_names = c("index", names(meta_columns), "individ"), multilocus_names = "index")

    if (success_message == "") {
        success_message <- "Data loaded without problems.<br />"
    }

    list("data" = data, "success_message" = success_message)
}


#' (load_data helper function) Loads a SQLite database from a file
#'
#' @param file_path The path to the *.db file to be loaded.
#' @param table The name of the table in the database that contains the desired data. Default is "Bears".
#' @param na_strings A vector of strings that will be changed to NA
#'
#' @return A table with all data from the table
#' @export
#'
#' @examples
#' \dontrun{
#' raw_data <- load_data_sqlite(file_path = "path/to/file.db", table = "Bears")
#' }
load_data_sqlite <- function(file_path, table = "Bears", na_strings = c("NA", "-99", "0", "000")) {
    db <- RSQLite::dbConnect(RSQLite::SQLite(), file_path)
    query <- sprintf("SELECT * FROM %s", table)

    raw_data <- RSQLite::dbGetQuery(db, query)
    RSQLite::dbDisconnect(db)

    raw_data <- as.data.frame(raw_data)
    raw_data <- apply(raw_data, 1:2, function(x) {
        if (x %in% na_strings) {
            return(NA)
        } else {
            return(x)
        }
    })

    as.data.frame(raw_data)
}

#' Create a single new data point from given data
#'
#' @param index The index of this datapoint.
#' @param multilocus A named vector with the multilocus of this datapoint.
#' @param meta A named vector with all metadata for this new datapoint.
#' @param na_strings A string with the values that are to be interpeted as NA values.
#'
#' @return A new_data object, similar to the data object but missing values in the "individ" column.
#' @export
#'
#' @examples
#' \dontrun{
#' locus_data <- c("110", "112", "143", "145", "123", "127", "164", "170", "150", "150", "230",
#'     "248", "184", "186", "128", "132")
#' names(locus_data) <- c("MU09 - 1", "MU09 - 2", "MU10 - 1", "MU10 - 2", "MU05 - 1", "MU05 - 2",
#'     "MU23 - 1", "MU23 - 2", "MU51 - 1", "MU51 - 2", "MU59 - 1", "MU59 - 2", "G10L - 1",
#'     "G10L - 2", "MU50 - 1", "MU50 - 2")
#
#' new_data <- create_new_data(index = "SEP123", multilocus = locus_data, meta =
#'     c(date = "2020-06-29", north = "7096503", east = "644381", gender = "Hane"))
#' }
create_new_data <- function(index, multilocus, meta, na_strings = c("NA", "-99", "000", "0")) {
    multilocus[multilocus %in% na_strings] <- NA

    multilocus[multilocus %in% na_strings] <- NA
    locus_data <- data.frame(as.list(as.numeric(multilocus)))
    colnames(locus_data) <- c(names(multilocus))
    rownames(locus_data) <- c(index)
    locus_data <- locus_data[,sort(colnames(locus_data))]

    combined_locus_data <- combine_multilocus(locus_data[1, ])
    names(combined_locus_data) <- index

    meta_data <- data.frame(index, as.list(meta), NA, NA)
    colnames(meta_data) <- c("index", names(meta), "individ", "date_changed")
    rownames(meta_data) <- c(index)

    meta_data$north <- as.numeric(meta_data$north)
    meta_data$east <- as.numeric(meta_data$east)

    ndata <- list(multilocus = locus_data, meta = meta_data, combined_locus_data = combined_locus_data, locus_column_names = names(multilocus), meta_column_names = c("index", names(meta), "individ"),
        distances = NULL)
    ndata
}


#' Load A File Containing New Data
#'
#' @description This is a wrapper function for load_data function.
#'
#' @param raw_data A table/data.frame with all columns that are to be extracted. Generated by the "load_raw_data" function.
#' @param index_column The name of the column containing the index.
#' @param locus_columns A vector with the names of the columns that contains the locus data.
#' @param meta_columns A vector with the names of the columns that contains the meta data.
#'
#' @return A new_data object, similar to a data object but missing the "individ" column.
#' @export
#'
#' @examples
#' \dontrun{
#' See "?load_data" and "?create_new_data"
#' }
create_new_data_batch <- function(raw_data, index_column, locus_columns, meta_columns) {
    load_data(raw_data, index_column = index_column, locus_columns = locus_columns, individ_column = NA, meta_columns = meta_columns)
}

#' Sanity Check New Data
#'
#' @param new_data A new_data object, created by the "create_new_data_batch" and "create_new_data" functions.
#' @param data A data object, created by the "load_data" function.
#'
#' @return A vector of messaged that contains information on the sanity of the new data.
#' @export
#'
#' @examples
#' \dontrun{
#' sanity_message <- sanity_check_new_data(new_data = new_data, data = data)
#' print(sanity_message)
#' }
sanity_check_new_data <- function(new_data, data) {
    problems <- c()

    locus_range <- apply(data$multilocus, 2, range, na.rm = TRUE)

    colnames(locus_range) <- colnames(data$multilocus)
    rownames(locus_range) <- c("min", "max")

    for (i in seq(nrow(new_data$multilocus))) {
        test_values <- new_data$multilocus[i,]

        names(test_values) <- colnames(new_data$multilocus)
        # Rearrange to match the correct locus with each other
        test_values <- test_values[colnames(locus_range)]
        outside_range <- test_values > locus_range["max",] | test_values < locus_range["min",]
        outside_range[is.na(outside_range)] <- FALSE
        if (any(outside_range, na.rm = TRUE)) {
            problems <- c(problems, paste(new_data$meta$index[i], "had some values outside the expected range. The problematic locuses are:", paste(names(test_values)[outside_range], collapse = ", ")))
        }
    }

    if (length(problems) >= 1) {
        problems <- c("Some values are outside the range of the rest of the dataset, ensure that this is inteded and that the locuses are in the correct order.", problems)
    }

    for (i in seq(nrow(new_data$multilocus))) {
        if (sum(is.na(new_data$multilocus[i,])) > 4) {
            problems <- c(problems, paste(new_data$meta$index[i], "There are more than 4 points of missing data, this will lead to large uncertenty when matching against the dataset"))
        }
    }

    for (new_ind in new_data$meta$index) {
        if (new_ind %in% data$meta$index) {
            problems <- c(problems, paste(new_ind, " already exists in the loaded data. Be aware that the program cannot handle this and it may lead to crashes and/or weird behaviour."))
        }
    }

    if (length(problems) == 0) {
        return("No problems were found with the new data.")
    } else {
        return(problems)
    }
}

#' An Euclidian Distance function
#'
#' @param multilocus1 A vector with the locuses of the first object to be compared.
#' @param multilocus2 A vector with the locuses of the second object to be compared.
#'
#' @return The euclidian distance between the locuses.
#' @export
#'
#' @examples
#' \dontrun{
#' l1 <- c(182, 180, 178, 176)
#' l2 <- c(178, 180, 178, 178)
#' dis <- dist_euclidian(l1, l2)
#' }
dist_euclidian <- function(multilocus1, multilocus2) {
    sqrt(sum((multilocus1 - multilocus2) ^ 2, na.rm = TRUE))
}

#' An Manhattan Distance function
#'
#' @param multilocus1 A vector with the locuses of the first object to be compared.
#' @param multilocus2 A vector with the locuses of the second object to be compared.
#'
#' @return The manhattan distance between the locuses.
#' @export
#'
#' @examples
#' \dontrun{
#' l1 <- c(182, 180, 178, 176)
#' l2 <- c(178, 180, 178, 178)
#' dis <- dist_euclidian(l1, l2)
#' }
dist_manhattan <- function(multilocus1, multilocus2) {
    sum(abs(multilocus1 - multilocus2), na.rm = TRUE)
}

#' An Maximum Distance function
#'
#' @param multilocus1 A vector with the locuses of the first object to be compared.
#' @param multilocus2 A vector with the locuses of the second object to be compared.
#'
#' @return The distance between the specific locuses that had the maximum distance.
#' @export
#'
#' @examples
#' \dontrun{
#' l1 <- c(182, 180, 178, 176)
#' l2 <- c(178, 180, 178, 180)
#' dis <- dist_euclidian(l1, l2)
#' }
dist_maximum <- function(multilocus1, multilocus2) {
    max(abs(multilocus1 - multilocus2), na.rm = TRUE)
}

#' An Number of Non-matches Distance function
#'
#' @param multilocus1 A vector with the locuses of the first object to be compared.
#' @param multilocus2 A vector with the locuses of the second object to be compared.
#'
#' @return The number of locuses that did not match. Missing data are counted as matches.
#' @export
#'
#' @examples
#' \dontrun{
#' l1 <- c(182, 180, 178, 176)
#' l2 <- c(178, 180, 178, 178)
#' dis <- dist_euclidian(l1, l2)
#' }
dist_num_mismatches <- function(multilocus1, multilocus2) {
    sum(!(multilocus1 == multilocus2), na.rm = TRUE)
}

#' Calculate the distances from the new data to the existing data.
#'
#' @param new_data A new_data object.
#' @param data A data object.
#' @param distance_function The function to be used for the distance. "dist_" functions are given by the package.
#'
#' @return A multi-dimentional list with the distance from each of the new data to the data.
#' @export
#'
#' @examples
#' \dontrun{
#' # OBS Apply the result of this function to the distance of the new_data, as this is required
#' # for other functions to work.
#'
#' new_data$distances <- calculate_new_data_distances(new_data = new_data, data = data,
#'     distance_function = dist_euclidian)
#'
#' }
calculate_new_data_distances <- function(new_data, data, distance_function) {

    distances <- list()
    combined_data <- rbind(data$multilocus, new_data$multilocus)
    data_rows <- split(combined_data, seq(nrow(combined_data)))

    for (ndata_row in seq(nrow(new_data$multilocus))) {
        distance <- mapply(distance_function, data_rows, split(new_data$multilocus, seq(nrow(new_data$multilocus)))[ndata_row])
        names(distance) <- rownames(combined_data)
        distance <- distance[names(distance) != new_data$meta$index[ndata_row]]
        distances <- append(distances, list(distance))
    }

    names(distances) <- new_data$meta$index

    distances
}

#' Combine A Vector Of Locuses Into A String
#'
#' @param locus A vector with the locuses.
#'
#' @return A string with all of the locuses combined.
#' @importFrom magrittr %>%
#' @export
#'
#' @examples
#' \dontrun{
#' print(combine_multilocus(c(182, 180, NA, 96)))
#' [1] "182 180 000 096"
#' }
combine_multilocus <- function(locus) {
    locus[is.na(locus)] <- 0
    locus <- as.numeric(locus)
    locus %>% formatC(width = 3, flag = "0", format = "d") %>%
        paste0(collapse = " ")
}

#' Gather all of the data the user could be interested in when choosing to merge the new_data.
#'
#' @param possible_matches A possible_matches object generated by the "match_new_data" function
#' @param new_data A new_data object.
#' @param data A data object.
#' @param ind The index for which the dataframe should be generated.
#' @param include_extra_info Whether or not to include 'gender' and 'confirmed dead' columns in the export
#' @param include_individ_ids Add extra individ ids which will be included in the dataframe
#'
#' @return A dataframe with a index, multilocus, distance, and individ column. All data of every individual where atleast one point was
#' within the threshold is included in the dataframe.
#' @export
#'
#' @examples
#' \dontrun{
#' df <- generate_user_choice_data_frame(possible_matches = possible_matches,
#'     new_data = new_data, data = data, ind = "SEP0159539", include_extra_info = FALSE)
#' }
generate_user_choice_data_frame <- function(possible_matches, new_data, data, ind, include_extra_info, include_individ_ids = c()) {
    combined_meta <- rbind(data$meta, new_data$meta)
    ind_individual <- combined_meta[ind, "individ"]
    individuals <- unique(c(data$meta[possible_matches[[ind]]$ids, "individ"], ind_individual, include_individ_ids))
    ids <- data$meta[data$meta$individ %in% individuals, "index"]
    ids <- unique(c(ids, possible_matches[[ind]]$ids))
    ids <- ids[ids != ind]

    df <- data.frame(index = c(ind, ids))

    combined_data <- c(new_data$combined_locus_data, data$combined_locus_data)

    multi <- combined_data[c(ind, ids)]

    refrence_sample <- unlist(strsplit(multi[ind], " "))
    multi[ids] <- lapply(multi[ids], function(x) {
        parts <- unlist(strsplit(x, " "))
        parts[parts != refrence_sample] <- paste0('<span style="color:red;">', parts[parts != refrence_sample], '</span>')
        paste0(parts, collapse = " ")
    }) %>% unlist

    distance <- c(NA, new_data$distances[[ind]][ids])
    names(distance)[1] <- ind

    indi <- c(NA, data$meta[ids,"individ"])
    names(indi)[1] <- ind
    if (!is.na(data$meta[ind, "individ"])) {
        indi[1] <- data$meta[ind, "individ"]
    }

    columns_included <- c("index", "multilocus", "locus distance", "individual")

    if (include_extra_info) {
        gender <- combined_meta[c(ind, ids), "gender"]
        confirmed_dead <- combined_meta[c(ind, ids), "confirmed_dead"]

        columns_included <- c("index", "multilocus", "gender", "confirmed dead", "locus distance", "individual")
        df <- cbind(df, data.frame(multilocus = multi), gender, confirmed_dead, distance, indi)
    } else {
        df <- cbind(df, data.frame(multilocus = multi), distance, indi)
    }

    df <- df[order(df$distance, na.last = FALSE),]
    colnames(df) <- columns_included
    rownames(df) <- df$index

    df
}

#' Generate threshold plot
#'
#' @param new_data A new_data object.
#' @param data A data object.
#'
#' @return Renders a plot showing how different thresholds would affect the resulting merge.
#' @importFrom graphics legend lines
#' @export
#'
#' @examples
#' \dontrun{
#' generate_threshold_plot(new_data = new_data, data = data)
#' }
generate_threshold_plot <- function(new_data, data) {
    min_dist <- min(unlist(new_data$distances))
    max_dist <- max(unlist(lapply(new_data$meta$index, function(ind) {
        sum(sort(new_data$distances[[ind]])[1:2], na.rm = TRUE)
    })))

    temp_thres <- min_dist + (max_dist - min_dist) * seq(0, 1, 0.01)
    matches <- data.frame(lapply(temp_thres, function(thres) {
        nums <- data.frame(lapply(new_data$meta$index, function(ind) {
            ids <- names(new_data$distances[[ind]])[new_data$distances[[ind]] <= thres]
            ids <- ids[ids %in% data$meta$index]
            num_matches <- length(unique(data$meta[ids, "individ"]))
            c(num_matches >= 2, num_matches == 0)
        }))

        c(sum(unlist(nums[1,])), sum(unlist(nums[2,])))
    }))

    plot(x = temp_thres, y = matches[1,], xlab = "Threshold", ylab = "Number Of New Samples", col = "red", type = "l", lwd = 2)
    lines(x = temp_thres, y = matches[2,], col = "blue", lwd = 2)
    legend(x = "right", y = (min(temp_thres) + max(temp_thres)) / 2, legend = c("Non-matches", "Multiple Matches"), col = c("blue", "red"), lty = 1, pch = 16)
}

#' Match New Data (Generate possible_matches object)
#'
#' @param new_data A new_data object.
#' @param threshold A value for under which threshold the new data will be matched to the existing data.
#'
#' @return A named list containing a vector of all data with a distance under the threshold. If the new_data$distances is generated as
#' expected, new_data can be matched against both new_data and data points. Be aware the refrenced indexes might exist in different objects.
#' @export
#'
#' @examples
#' \dontrun{
#' possible_matches <- match_new_data(new_data = new_data, threshold = threshold)
#' }
match_new_data <- function(new_data, threshold) {
    if (is.null(new_data$distances)) {
        warning("The new data needs to get the distances assigned to it, use the 'calculate_new_data_distances' function")
        return(NULL)
    }

    possible_matches <- list()
    for (new_ind in new_data$meta$index) {
        possible_matches <- append(possible_matches, list(list(ids = names(new_data$distances[[new_ind]][new_data$distances[[new_ind]] <= threshold]))))
    }
    names(possible_matches) <- new_data$meta$index
    possible_matches
}

#' Extract One Index From Batch of New_Data
#'
#' @param batch A new_data object.
#' @param index The index of the new_data to be extracted.
#'
#' @return A new_data object that only contains one point of new data.
#' @export
#'
#' @examples
#' \dontrun{
#' new_data_one <- extract_one_index_from_batch(batch = new_data, index = "SEP0159539")
#' }
extract_one_index_from_batch <- function(batch, index) {
    list(multilocus = batch$multilocus[index,], meta = batch$meta[index,], locus_column_names = batch$locus_column_names,
        meta_column_names = batch$meta_column_names, multilocus_names = batch$multilocus_names, combined_locus_data = batch$combined_locus_data[[index]])
}

#' Merge New Data Into The Dataset
#'
#' @param new_data A new_data object with one datapoint. Generated by extract_one_index_from_batch.
#' @param data A data object.
#' @param new_data_id The new individ-id for the datapoint in new_data.
#' @param date_of_change The data generated by 'Sys.time()' of the time when the object was merged, in order to set same timestamp for all objects of change and avoid a second difference.
#'
#' @return A list with $data that contains the new data and $success that is either TRUE or FALSE depending on if the function succeeded.
#' The test is rudimentary and weird/broken or corrupt data may be generated even if this value is TRUE.
#' @export
#'
#' @examples
#' \dontrun{
#' ind <- "SEP0159539"
#' new_id <- possible_matches[[ind]]$ids[1]
#' merged_data <- merge_new_data(new_data = extract_one_index_from_batch(batch = new_data,
#'     index = ind), data = data, new_data_id = new_id)
#' }
merge_new_data <- function(new_data, data, new_data_id, date_of_change = Sys.time()) {
    if (is.na(new_data_id) | is.null(new_data_id)) {
        return(list(data = data, success = FALSE))
    }

    if (new_data$meta$index[1] %in% data$meta$index) {
        return(list(data = data, success = FALSE))
    }

    ids <- data$meta[data$meta$individ == new_data_id, "index"]
    if ("Yes" %in% data$meta[ids, "confirmed_dead"]) {
        new_data$meta$confirmed_dead <- "Yes"
    }

    if ("Yes" %in% new_data$meta$confirmed_dead) {
        data$meta[ids, "confirmed_dead"] <- "Yes"
    }

    new_data$meta$date_changed <- c(format(lubridate::ymd_hms(date_of_change)))

    df_multi <- data.frame(as.list(new_data$multilocus))
    rownames(df_multi) <- new_data$meta$index
    colnames(df_multi) <- colnames(data$multilocus)
    data$multilocus <- rbind(data$multilocus, df_multi)
    new_data$meta$individ <- new_data_id
    data$meta <- rbind(data$meta, new_data$meta)

    names(new_data$combined_locus_data) <- new_data$meta$index
    data$combined_locus_data <- c(data$combined_locus_data, new_data$combined_locus_data)

    list(data = data, success = TRUE)
}
